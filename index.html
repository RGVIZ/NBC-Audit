<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audit Decision Matrix</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Roboto', 'sans-serif'],
            },
            colors: {
              // Custom colors matching the requirement
              'primary-orange': '#FF9800',
              'sidebar-dark': '#263238',
              'view-blue': '#1976D2',
              'edit-grey': '#9E9E9E',
              'delete-red': '#D32F2F',
              'table-header-bg': '#E3F2FD',
              'row-hover-bg': '#F1F1F1',
            }
          }
        }
      }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/uuid@8.3.2/dist/umd/uuid.min.js"></script>
</head>
<body class="antialiased">
    <div id="root"></div>

    <script type="text/babel">
        // Use global variables provided by the CDNs
        const { useState, useEffect, useMemo } = React;
        const v4 = uuid.v4;
        
        // --- Local Storage Keys ---
        const DECISION_RECORDS_KEY = 'auditDecisionRecords';
        const SCHEDULE_RECORDS_KEY = 'auditScheduleRecords';

        // --- Utility Functions ---

        /** Initializes or retrieves data from localStorage. */
        const getLocalStorageItem = (key, defaultValue) => {
          try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
          } catch (error) {
            console.error(`Error reading localStorage key "${key}":`, error);
            return defaultValue;
          }
        };

        /** Sets data to localStorage. */
        const setLocalStorageItem = (key, value) => {
          try {
            window.localStorage.setItem(key, JSON.stringify(value));
          } catch (error) {
            console.error(`Error writing localStorage key "${key}":`, error);
          }
        };

        /** Calculates Percentage Change. */
        const calculatePctChange = (targetPPM, actualPPM) => {
          if (targetPPM === 0 || targetPPM === null || targetPPM === undefined) {
            return 'N/A';
          }
          const pctChange = ((targetPPM - actualPPM) / targetPPM) * 100;
          return parseFloat(pctChange.toFixed(2));
        };

        /** Looks up rating based on a numeric value and rules. */
        const lookupRating = (value, rules) => {
          if (value === 'N/A' || value === null || value === undefined) return null;

          // Assumes rules are sorted ascending by 'max'
          const rule = (rules || []).find(r => value <= r.max);
          return rule ? r.rating : null;
        };

        /** Looks up frequency based on the final rating. */
        const lookupFrequency = (finalRating, rules) => {
          if (finalRating === null || finalRating === undefined) return { frequency: null, color: null };

          const rule = (rules || []).find(r => r.finalRating === finalRating);
          return rule ? { frequency: r.frequency, color: r.color } : { frequency: null, color: null };
        };

        /** Calculates all derived fields for a decision matrix row. */
        const calculateRowData = (row, rules) => {
          const { targetPPM, actualPPM, complaints } = row;

          // 1. % Change
          const pctChange = calculatePctChange(targetPPM, actualPPM);

          // 2. PPM Rating
          const pctChangeRating = lookupRating(pctChange, rules.pctChangeRules);

          // 3. Complaint Rating
          const complaintRating = lookupRating(complaints, rules.complaintRules);

          // 4. Final Rating (Multiplication)
          let finalRating = null;
          if (pctChangeRating !== null && complaintRating !== null) {
            finalRating = pctChangeRating * complaintRating;
          }

          // 5. Frequency
          const { frequency, color: frequencyColor } = lookupFrequency(finalRating, rules.frequencyRules);

          return {
            ...row,
            pctChange,
            pctChangeRating,
            complaintRating,
            finalRating,
            frequency,
            frequencyColor,
          };
        };

        // --- Custom Hooks ---

        /** Custom hook for managing the single-page application's route via URL hash. */
        const useRoute = () => {
          // Initialize from hash or default
          const [route, setRoute] = useState(window.location.hash.slice(1) || 'audit-decision-matrix');

          useEffect(() => {
            const handleHashChange = () => {
              setRoute(window.location.hash.slice(1) || 'audit-decision-matrix');
            };

            window.addEventListener('hashchange', handleHashChange);
            return () => window.removeEventListener('hashchange', handleHashChange);
          }, []);

          const navigate = (path) => {
            window.location.hash = path;
          };

          const [path, id] = route.split('/');
          const params = path === 'decision-matrix' && id ? { id } : {};

          return { route: path, params, navigate };
        };

        // --- Tailwind CSS Classes (as constants) ---

        const COLORS = {
          primary: 'bg-[#FF9800] text-white',
          view: 'bg-[#1976D2] text-white',
          edit: 'bg-[#9E9E9E] text-white',
          delete: 'bg-[#D32F2F] text-white',
          cancel: 'bg-[#9E9E9E] text-black',
          sidebarBg: 'bg-[#263238]',
          sidebarText: 'text-white',
          activeSidebar: 'bg-[#FF9800]',
          tableHeader: 'bg-[#E3F2FD]',
          rowHover: 'hover:bg-[#F1F1F1]',
        };

        const BUTTON_BASE = 'px-3 py-1 text-sm rounded transition-colors duration-150';
        const PRIMARY_BUTTON = `${BUTTON_BASE} ${COLORS.primary}`;
        const VIEW_BUTTON = `${BUTTON_BASE} ${COLORS.view}`;
        const EDIT_BUTTON = `${BUTTON_BASE} ${COLORS.edit}`;
        const DELETE_BUTTON = `${BUTTON_BASE} ${COLORS.delete}`;
        const CANCEL_BUTTON = `${BUTTON_BASE} ${COLORS.cancel}`;

        const INPUT_BASE = 'border border-gray-300 p-2 rounded w-full focus:ring-2 focus:ring-[#FF9800]';

        // --- Components: Shared UI Elements ---

        const Modal = ({ title, isOpen, onClose, children, footer, size = 'max-w-xl' }) => {
          if (!isOpen) return null;

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 font-sans" onClick={onClose}>
              <div className={`bg-white rounded-lg shadow-xl p-6 m-4 ${size}`} onClick={(e) => e.stopPropagation()}>
                <h2 className="text-xl font-bold mb-4 border-b pb-2">{title}</h2>
                <div className="max-h-[80vh] overflow-y-auto pr-2">
                  {children}
                </div>
                {footer && <div className="mt-4 pt-4 border-t flex justify-end space-x-2">{footer}</div>}
              </div>
            </div>
          );
        };

        const Sidebar = ({ navigate, activeRoute }) => {
          const items = [
            { name: 'Audit Decision Matrix', route: 'audit-decision-matrix' },
            { name: 'Audit Schedule', route: 'audit-schedule' },
          ];

          return (
            <div className={`fixed left-0 top-0 h-screen w-[220px] ${COLORS.sidebarBg} ${COLORS.sidebarText} font-sans shadow-lg`}>
              <h1 className="text-xl font-bold p-4 border-b border-gray-700">Audit System</h1>
              <nav className="p-2 space-y-1">
                {items.map((item) => (
                  <div
                    key={item.route}
                    className={`p-3 rounded cursor-pointer transition-colors ${activeRoute === item.route ? COLORS.activeSidebar : 'hover:bg-[#37474F]'}`}
                    onClick={() => navigate(item.route)}
                  >
                    {item.name}
                  </div>
                ))}
              </nav>
            </div>
          );
        };

        const ConfirmModal = ({ isOpen, title, message, onConfirm, onCancel }) => {
          return (
            <Modal
              title={title}
              isOpen={isOpen}
              onClose={onCancel}
              footer={
                <>
                  <button className={CANCEL_BUTTON} onClick={onCancel}>Cancel</button>
                  <button className={DELETE_BUTTON} onClick={onConfirm}>Confirm Delete</button>
                </>
              }
            >
              <p>{message}</p>
            </Modal>
          );
        };

        // --- Components: Modals ---

        const UpsertDecisionMatrixModal = ({
          isOpen,
          onClose,
          onSubmit,
          initialData = null,
          isEdit = false
        }) => {
          const [formData, setFormData] = useState({
            name: initialData?.name || '',
            appliesTo: initialData?.appliesTo || 'Line', // Default for new records
            appliesToDetail: initialData?.appliesToDetail || '',
            coordinator: initialData?.coordinator || '',
            description: initialData?.description || '',
          });

          const isFormValid = useMemo(() => {
            return formData.name.length > 0 && formData.coordinator.length > 0;
          }, [formData]);

          const handleChange = (e) => {
            const { name, value } = e.target;
            setFormData(prev => ({ ...prev, [name]: value }));
          };

          const handleAppliesToChange = (e) => {
            const value = e.target.value;
            setFormData(prev => ({
              ...prev,
              appliesTo: value,
              appliesToDetail: '', // Reset detail when appliesTo changes
            }));
          };

          const handleSubmit = (e) => {
            e.preventDefault();
            if (!isFormValid) return;

            onSubmit(formData);
            onClose();
          };

          // Helper to get the correct label/placeholder for the detail field
          const getDetailFieldConfig = () => {
            switch (formData.appliesTo) {
              case 'Line': return { label: 'Line Identifier', placeholder: 'e.g., Line A' };
              case 'Plant': return { label: 'Plant Code', placeholder: 'e.g., P001' };
              case 'Supplier': return { label: 'Supplier Name', placeholder: 'e.g., Acme Ltd' };
              default: return { label: 'Detail', placeholder: '' };
            }
          };

          const detailConfig = getDetailFieldConfig();

          return (
            <Modal
              title={isEdit ? 'Edit Decision Matrix' : 'Create New Decision Matrix'}
              isOpen={isOpen}
              onClose={onClose}
              footer={
                <>
                  <button className={CANCEL_BUTTON} onClick={onClose}>Cancel</button>
                  <button
                    className={PRIMARY_BUTTON}
                    onClick={handleSubmit}
                    disabled={!isFormValid}
                    style={{ opacity: isFormValid ? 1 : 0.5, cursor: isFormValid ? 'pointer' : 'not-allowed' }}
                  >
                    {isEdit ? 'Save changes' : 'Create'}
                  </button>
                </>
              }
            >
              <form onSubmit={handleSubmit} className="space-y-4">
                {/* Name */}
                <div>
                  <label className="block text-sm font-medium mb-1">Name*</label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleChange}
                    maxLength={100}
                    className={INPUT_BASE}
                    required
                  />
                </div>

                {/* Applies To */}
                <div>
                  <label className="block text-sm font-medium mb-1">Applies To*</label>
                  <div className="flex space-x-4">
                    {['Line', 'Plant', 'Supplier'].map(option => (
                      <label key={option} className="flex items-center space-x-1">
                        <input
                          type="radio"
                          name="appliesTo"
                          value={option}
                          checked={formData.appliesTo === option}
                          onChange={handleAppliesToChange}
                          required
                        />
                        <span>{option}</span>
                      </label>
                    ))}
                  </div>
                </div>

                {/* Applies To Detail (Optional based on radio selection) */}
                {formData.appliesTo && (
                  <div>
                    <label className="block text-sm font-medium mb-1">{detailConfig.label}</label>
                    <input
                      type="text"
                      name="appliesToDetail"
                      value={formData.appliesToDetail}
                      onChange={handleChange}
                      placeholder={detailConfig.placeholder}
                      className={INPUT_BASE}
                    />
                  </div>
                )}

                {/* Coordinator */}
                <div>
                  <label className="block text-sm font-medium mb-1">Coordinator*</label>
                  <input
                    type="text"
                    name="coordinator"
                    value={formData.coordinator}
                    onChange={handleChange}
                    maxLength={80}
                    className={INPUT_BASE}
                    required
                  />
                </div>

                {/* Description */}
                <div>
                  <label className="block text-sm font-medium mb-1">Description</label>
                  <textarea
                    name="description"
                    value={formData.description}
                    onChange={handleChange}
                    rows={3}
                    maxLength={500}
                    className={INPUT_BASE}
                  />
                </div>
              </form>
            </Modal>
          );
        };

        const RuleConfigModal = ({ isOpen, onClose, rules, onSave }) => {
          const [currentRules, setCurrentRules] = useState(rules);
          const [activeTab, setActiveTab] = useState('pctChangeRules');

          useEffect(() => {
            setCurrentRules(rules);
          }, [rules]);

          const updateRule = (type, index, field, value) => {
            const newRules = [...(currentRules[type] || [])];
            newRules[index][field] = value;
            setCurrentRules(prev => ({ ...prev, [type]: newRules }));
          };

          const addRule = (type) => {
            let newRule = {};
            if (type === 'frequencyRules') {
              newRule = { finalRating: '', frequency: '', color: '#000000' };
            } else {
              // Ensure 'max' is handled correctly as a number or empty string
              newRule = { rating: 1, max: '', description: '' };
            }

            setCurrentRules(prev => ({ ...prev, [type]: [...(prev[type] || []), newRule] }));
          };

          const deleteRule = (type, index) => {
            const newRules = (currentRules[type] || []).filter((_, i) => i !== index);
            setCurrentRules(prev => ({ ...prev, [type]: newRules }));
          };

          const renderRulesForm = (type, rulesList, title, fields) => (
            <div className="space-y-4">
              <div className="flex justify-between items-center">
                <h3 className="text-lg font-semibold">{title}</h3>
                <button className={`${PRIMARY_BUTTON}`} onClick={() => addRule(type)}>+ Add Rule</button>
              </div>

              <div className="space-y-3">
                {(rulesList || []).map((rule, index) => (
                  <div key={index} className="border p-3 rounded grid grid-cols-12 gap-2 items-end">
                    {fields.map(field => (
                      <div key={field.name} className={`col-span-${field.span}`}>
                        <label className="block text-xs font-medium mb-1">{field.label}</label>
                        {field.type === 'color' ? (
                          <input
                            type="color"
                            value={rule[field.name]}
                            onChange={(e) => updateRule(type, index, field.name, e.target.value)}
                            className="w-full h-10 p-1 border-gray-300 rounded"
                          />
                        ) : (
                          <input
                            type={field.type}
                            value={rule[field.name]}
                            onChange={(e) => {
                              const val = field.type === 'number' ? (e.target.value === '' ? '' : parseFloat(e.target.value)) : e.target.value;
                              updateRule(type, index, field.name, val);
                            }}
                            className={INPUT_BASE}
                            min={field.min}
                            max={field.max}
                            placeholder={field.placeholder}
                            required={field.required}
                          />
                        )}
                      </div>
                    ))}
                    <div className="col-span-2 text-right">
                      <button className={`${DELETE_BUTTON}`} onClick={() => deleteRule(type, index)}>Delete</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          );

          const ruleConfigs = {
            pctChangeRules: {
              title: '% Change Rules',
              fields: [
                { name: 'rating', label: 'PPM Rating (1-5)', type: 'number', span: 2, min: 1, max: 5, required: true },
                { name: 'max', label: 'Max % Change', type: 'number', span: 3, placeholder: 'e.g., 5.00', required: true },
                { name: 'description', label: 'Description', type: 'text', span: 5, placeholder: 'e.g., Less than 5%', required: true },
              ],
            },
            complaintRules: {
              title: 'Complaint Rules',
              fields: [
                { name: 'rating', label: 'Complaint Rating (1-5)', type: 'number', span: 2, min: 1, max: 5, required: true },
                { name: 'max', label: 'Max Complaints', type: 'number', span: 3, min: 0, placeholder: 'e.g., 5', required: true },
                { name: 'description', label: 'Description', type: 'text', span: 5, placeholder: 'e.g., 5 or fewer complaints', required: true },
              ],
            },
            frequencyRules: {
              title: 'Frequency Rules',
              fields: [
                { name: 'finalRating', label: 'Final Rating (Product)', type: 'number', span: 2, min: 1, required: true },
                { name: 'frequency', label: 'Frequency', type: 'text', span: 3, placeholder: 'e.g., Monthly', required: true },
                { name: 'color', label: 'Label Color', type: 'color', span: 3, required: true },
              ],
            },
          };

          return (
            <Modal
              title="Configure Decision Matrix Rules"
              isOpen={isOpen}
              onClose={onClose}
              size="max-w-4xl"
              footer={
                <>
                  <button className={CANCEL_BUTTON} onClick={onClose}>Close</button>
                  <button className={PRIMARY_BUTTON} onClick={() => onSave(currentRules)}>Save Rules</button>
                </>
              }
            >
              <div className="flex border-b mb-4">
                {Object.keys(ruleConfigs).map(key => (
                  <button
                    key={key}
                    className={`p-3 border-b-2 transition-colors ${activeTab === key ? 'border-[#FF9800] text-[#FF9800]' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                    onClick={() => setActiveTab(key)}
                  >
                    {ruleConfigs[key].title}
                  </button>
                ))}
              </div>

              {activeTab === 'pctChangeRules' && renderRulesForm('pctChangeRules', currentRules.pctChangeRules, ruleConfigs.pctChangeRules.title, ruleConfigs.pctChangeRules.fields)}
              {activeTab === 'complaintRules' && renderRulesForm('complaintRules', currentRules.complaintRules, ruleConfigs.complaintRules.title, ruleConfigs.complaintRules.fields)}
              {activeTab === 'frequencyRules' && renderRulesForm('frequencyRules', currentRules.frequencyRules, ruleConfigs.frequencyRules.title, ruleConfigs.frequencyRules.fields)}
            </Modal>
          );
        };

        // --- Components: Audit Decision Matrix Listing Page ---

        const RecordCard = ({ record, navigate, onDelete, onEdit }) => {
          const appliesToText = record.appliesToDetail
            ? `${record.appliesTo} (${record.appliesToDetail})`
            : record.appliesTo;

          return (
            <div className="p-4 border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow bg-white">
              <div className="flex justify-between items-start">
                <div>
                  <h3 className="text-xl font-bold mb-1">{record.name}</h3>
                  <p className="text-sm text-gray-600 mb-1">Applies To: <span className="font-medium">{appliesToText}</span></p>
                  <p className="text-sm text-gray-600">Coordinator: <span className="font-medium">{record.coordinator}</span></p>
                </div>
                <div className="flex space-x-2">
                  <button className={VIEW_BUTTON} onClick={() => navigate(`decision-matrix/${record.id}`)}>View</button>
                  <button className={EDIT_BUTTON} onClick={() => onEdit(record)}>Edit</button>
                  <button className={DELETE_BUTTON} onClick={() => onDelete(record.id)}>Delete</button>
                </div>
              </div>
            </div>
          );
        };

        const AuditDecisionMatrixListing = ({ navigate, records, setRecords }) => {
          const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
          const [isEditModalOpen, setIsEditModalOpen] = useState(false);
          const [isConfirmOpen, setIsConfirmOpen] = useState(false);
          const [recordToDelete, setRecordToDelete] = useState(null);
          const [recordToEdit, setRecordToEdit] = useState(null);

          // Handlers
          const handleCreateRecord = (formData) => {
            const now = new Date().toISOString();
            const newRecord = {
              id: `dm_${v4()}`,
              ...formData,
              createdAt: now,
              updatedAt: now,
              rows: [],
              rules: {
                pctChangeRules: [],
                complaintRules: [],
                frequencyRules: [],
              },
            };

            // Newest first
            const newRecords = [newRecord, ...records]; 
            setRecords(newRecords);
          };

          const handleDeleteClick = (id) => {
            setRecordToDelete(id);
            setIsConfirmOpen(true);
          };

          const handleConfirmDelete = () => {
            const newRecords = records.filter(r => r.id !== recordToDelete);
            setRecords(newRecords);
            setRecordToDelete(null);
            setIsConfirmOpen(false);
          };

          const handleEditClick = (record) => {
            setRecordToEdit(record);
            setIsEditModalOpen(true);
          };

          const handleUpdateRecord = (updatedData) => {
            const now = new Date().toISOString();
            const updatedRecord = {
              ...recordToEdit,
              ...updatedData,
              updatedAt: now,
            };

            const newRecords = records.map(r =>
              r.id === updatedRecord.id ? updatedRecord : r
            );
            setRecords(newRecords);
            setRecordToEdit(null);
          };

          return (
            <div className="p-6">
              {/* Top Bar */}
              <div className="flex justify-between items-center mb-6 border-b pb-4">
                <h1 className="text-3xl font-bold">Audit Decision Matrix</h1>
                <button
                  className={PRIMARY_BUTTON}
                  onClick={() => setIsCreateModalOpen(true)}
                >
                  + Add Record
                </button>
              </div>

              {/* Record Cards Listing (Newest first) */}
              <div className="space-y-4">
                {records.length === 0 ? (
                  <p className="text-gray-500">No decision matrix records found. Click "+ Add Record" to create one.</p>
                ) : (
                  records.map((record) => (
                    <RecordCard
                      key={record.id}
                      record={record}
                      navigate={navigate}
                      onDelete={handleDeleteClick}
                      onEdit={handleEditClick}
                    />
                  ))
                )}
              </div>

              {/* Modals */}
              <UpsertDecisionMatrixModal
                isOpen={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
                onSubmit={handleCreateRecord}
              />

              {recordToEdit && (
                <UpsertDecisionMatrixModal
                  isOpen={isEditModalOpen}
                  onClose={() => setIsEditModalOpen(false)}
                  onSubmit={handleUpdateRecord}
                  initialData={recordToEdit}
                  isEdit={true}
                />
              )}

              <ConfirmModal
                isOpen={isConfirmOpen}
                title="Confirm Deletion"
                message={`Are you sure you want to delete the Decision Matrix "${recordToDelete ? records.find(r => r.id === recordToDelete)?.name : ''}"? This action cannot be undone.`}
                onConfirm={handleConfirmDelete}
                onCancel={() => setIsConfirmOpen(false)}
              />
            </div>
          );
        };

        // --- Components: Decision Matrix Record Page (/decision-matrix/{id}) ---

        const DecisionMatrixRow = ({ row, rules, onUpdate, onDelete, isEditing, setIsEditing }) => {
          const [editData, setEditData] = useState(row);

          useEffect(() => {
            setEditData(row);
          }, [row]);

          const handleChange = (e) => {
            const { name, value } = e.target;
            // Auto-convert numeric fields
            const val = ['targetPPM', 'actualPPM', 'complaints'].includes(name)
              ? (value === '' ? '' : parseFloat(value))
              : value;

            setEditData(prev => ({ ...prev, [name]: val }));
          };

          const handleSave = () => {
            // Check for required number fields to be non-empty before calculating
            if (editData.targetPPM === '' || editData.actualPPM === '' || editData.complaints === '') {
                alert("Please ensure Target PPM, Actual PPM, and Complaints are filled with numeric values before saving.");
                return;
            }

            // Recalculate all fields based on the raw inputs
            const updatedRow = calculateRowData(editData, rules);
            onUpdate(updatedRow);
            setIsEditing(false);
          };

          const handleCancel = () => {
            setEditData(row); // Reset to original data
            setIsEditing(false);
          };

          const AppliesToInstanceCell = isEditing ? (
            <input
              type="text"
              name="appliesToInstance"
              value={editData.appliesToInstance}
              onChange={handleChange}
              className={`${INPUT_BASE} p-1 text-sm`}
            />
          ) : (
            <span className="font-medium">{row.appliesToInstance}</span>
          );

          const PPMInputCell = (name, value) => isEditing ? (
            <input
              type="number"
              name={name}
              value={value}
              onChange={handleChange}
              className={`${INPUT_BASE} p-1 text-sm text-right`}
              min="0"
              step="0.01"
            />
          ) : (
            <span className="text-right block">{value}</span>
          );

          const ComplaintsCell = isEditing ? (
            <input
              type="number"
              name="complaints"
              value={editData.complaints}
              onChange={handleChange}
              className={`${INPUT_BASE} p-1 text-sm text-right`}
              min="0"
              step="1"
            />
          ) : (
            <span className="text-right block">{row.complaints}</span>
          );

          const ActionButtons = isEditing ? (
            <div className="flex space-x-2 justify-end">
              <button className={`${PRIMARY_BUTTON} px-2 py-0.5`} onClick={handleSave}>Save</button>
              <button className={`${CANCEL_BUTTON} px-2 py-0.5`} onClick={handleCancel}>Cancel</button>
            </div>
          ) : (
            <div className="flex space-x-2 justify-end">
              <button className={`${EDIT_BUTTON} px-2 py-0.5`} onClick={() => setIsEditing(true)}>Edit</button>
              <button className={`${DELETE_BUTTON} px-2 py-0.5`} onClick={() => onDelete(row.rowId)}>Delete</button>
            </div>
          );

          return (
            <tr className={`${COLORS.rowHover}`}>
              <td className="p-2 border">{AppliesToInstanceCell}</td>
              <td className="p-2 border text-right">{PPMInputCell('targetPPM', editData.targetPPM)}</td>
              <td className="p-2 border text-right">{PPMInputCell('actualPPM', editData.actualPPM)}</td>
              <td className="p-2 border text-right font-mono">{row.pctChange !== 'N/A' ? `${row.pctChange}%` : 'N/A'}</td>
              <td className="p-2 border text-center">{row.pctChangeRating || '-'}</td>
              <td className="p-2 border text-right">{ComplaintsCell}</td>
              <td className="p-2 border text-center">{row.complaintRating || '-'}</td>
              <td className="p-2 border text-center font-bold">{row.finalRating || '-'}</td>
              <td className="p-2 border text-center w-[150px]">
                {row.frequency && (
                  <span className="px-2 py-1 rounded text-white text-xs font-semibold whitespace-nowrap" style={{ backgroundColor: row.frequencyColor }}>
                    {row.frequency}
                  </span>
                )}
              </td>
              <td className="p-2 border w-[150px]">{ActionButtons}</td>
            </tr>
          );
        };

        const DecisionMatrixRecordPage = ({ id, records, setRecords, navigate, setScheduledRecords }) => {
          const record = useMemo(() => records.find(r => r.id === id), [id, records]);

          const [isRulesModalOpen, setIsRulesModalOpen] = useState(false);
          const [isConfirmDeleteRowOpen, setIsConfirmDeleteRowOpen] = useState(false);
          const [rowToDelete, setRowToDelete] = useState(null);
          // Only one row can be edited at a time
          const [editingRowId, setEditingRowId] = useState(null); 

          useEffect(() => {
            if (!record) {
              // Redirect if record not found
              navigate('audit-decision-matrix');
            }
          }, [record, navigate]);

          if (!record) return null; // Wait for redirect

          const updateRecordInState = (updatedRecord) => {
            const newRecords = records.map(r =>
              r.id === updatedRecord.id ? { ...updatedRecord, updatedAt: new Date().toISOString() } : r
            );
            setRecords(newRecords);
          };

          // --- Rules Handlers ---
          const handleSaveRules = (newRules) => {
            const updatedRecord = { ...record, rules: newRules };

            // Recalculate all rows after rules change
            const recalculatedRows = (record.rows || []).map(row => calculateRowData(row, newRules));
            updatedRecord.rows = recalculatedRows;

            updateRecordInState(updatedRecord);
            setIsRulesModalOpen(false);
          };

          // --- Row Handlers ---
          const handleAddRow = () => {
            // Prevent adding a new row if one is already being edited
            if (editingRowId) {
                alert("Please save or cancel the current row edit before adding a new row.");
                return;
            }
            
            const newRow = {
              rowId: `r_${v4()}`,
              appliesToInstance: '',
              targetPPM: '', // Use empty string to prompt for input
              actualPPM: '',
              complaints: '',
              // Calculated fields will be set on save
              pctChange: 'N/A',
              pctChangeRating: null,
              complaintRating: null,
              finalRating: null,
              frequency: null,
              frequencyColor: null,
            };
            // Newest row is added to the beginning of the array for display
            const updatedRecord = { ...record, rows: [newRow, ...(record.rows || [])] };
            updateRecordInState(updatedRecord);
            setEditingRowId(newRow.rowId); // Start editing the new row immediately
          };

          const handleUpdateRow = (updatedRow) => {
            const updatedRows = (record.rows || []).map(row =>
              row.rowId === updatedRow.rowId ? updatedRow : row
            );
            const updatedRecord = { ...record, rows: updatedRows };
            updateRecordInState(updatedRecord);
          };

          const handleDeleteRowClick = (rowId) => {
            setRowToDelete(rowId);
            setIsConfirmDeleteRowOpen(true);
          };

          const handleConfirmDeleteRow = () => {
            const updatedRows = (record.rows || []).filter(row => row.rowId !== rowToDelete);
            const updatedRecord = { ...record, rows: updatedRows };
            updateRecordInState(updatedRecord);
            setRowToDelete(null);
            setIsConfirmDeleteRowOpen(false);
            setEditingRowId(null); // Ensure no row is left in edit mode
          };

          // --- Schedule Handler ---
          const handleSendToSchedule = () => {
            // Check for uncalculated rows
            const hasUncalculatedRows = (record.rows || []).some(row => 
                row.finalRating === null || 
                row.targetPPM === '' || 
                row.actualPPM === '' || 
                row.complaints === ''
            );

            if (hasUncalculatedRows) {
              alert("Cannot send to schedule. Please ensure all rows are filled and saved, and all decision rules are configured correctly to generate a 'Final Rating' for every row.");
              return;
            }

            setScheduledRecords(prev => {
              // Prevent duplicates by ID: update if exists, add if new
              const existingIndex = prev.findIndex(r => r.id === record.id);
              if (existingIndex !== -1) {
                return prev.map((r, i) => i === existingIndex ? record : r);
              }
              return [...prev, record]; // Add new
            });
            alert(`Decision Matrix "${record.name}" sent to Audit Schedule successfully!`);
          };

          // --- Data Display ---
          const appliesToText = record.appliesToDetail
            ? `${record.appliesTo} (${record.appliesToDetail})`
            : record.appliesTo;

          const getRuleSummary = (rules, isFrequency = false) => {
            return (rules || []).map((r, i) => (
              <li key={i} className="text-sm">
                <span className="font-semibold">{isFrequency ? `FR ${r.finalRating} → ` : `R ${r.rating}: `}</span>
                {isFrequency ? (
                  <span className="px-2 py-0.5 rounded text-white text-xs font-semibold whitespace-nowrap" style={{ backgroundColor: r.color }}>
                    {r.frequency}
                  </span>
                ) : (
                  r.description
                )}
              </li>
            ));
          };

          return (
            <div className="p-6">
              {/* Header */}
              <div className="mb-6 border-b pb-4">
                <h1 className="text-3xl font-bold mb-1">{record.name}</h1>
                <p className="text-gray-600">Applies To: <span className="font-medium">{appliesToText}</span> | Coordinator: <span className="font-medium">{record.coordinator}</span></p>
                {record.description && <p className="mt-2 italic text-sm">{record.description}</p>}
              </div>

              {/* Rules Banner */}
              <div className="bg-gray-50 p-4 rounded shadow-inner mb-6">
                <div className="flex justify-between items-center mb-4 border-b pb-3">
                  <h2 className="text-xl font-bold">Decision Rules</h2>
                  <button className={VIEW_BUTTON} onClick={() => setIsRulesModalOpen(true)}>
                    Configure Rules
                  </button>
                </div>
                <div className="grid grid-cols-3 gap-6">
                  <div>
                    <h3 className="text-lg font-semibold mb-2">% Change Rules</h3>
                    <ul className="list-disc ml-5 space-y-1 text-sm">
                      {getRuleSummary(record.rules.pctChangeRules)}
                      {(record.rules.pctChangeRules || []).length === 0 && <li className="text-gray-500">No rules configured.</li>}
                    </ul>
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold mb-2">Complaint Rules</h3>
                    <ul className="list-disc ml-5 space-y-1 text-sm">
                      {getRuleSummary(record.rules.complaintRules)}
                      {(record.rules.complaintRules || []).length === 0 && <li className="text-gray-500">No rules configured.</li>}
                    </ul>
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold mb-2">Frequency Rules</h3>
                    <ul className="list-disc ml-5 space-y-1 text-sm">
                      {getRuleSummary(record.rules.frequencyRules, true)}
                      {(record.rules.frequencyRules || []).length === 0 && <li className="text-gray-500">No rules configured.</li>}
                    </ul>
                  </div>
                </div>
              </div>

              {/* Decision Matrix Table */}
              <h2 className="text-xl font-bold mb-3">Matrix Data</h2>
              <div className="flex justify-end mb-2">
                <button className={PRIMARY_BUTTON} onClick={handleAddRow} disabled={editingRowId !== null}>
                  + Add Row
                </button>
              </div>

              <div className="overflow-x-auto border rounded-lg shadow-md">
                <table className="min-w-full table-auto text-sm">
                  <thead>
                    <tr className={`${COLORS.tableHeader} text-left text-sm`}>
                      {['Applies To Instance', 'Target PPM', 'Actual PPM', '% Change', 'PPM Rating', 'Complaints', 'Complaint Rating', 'Final Rating', 'Frequency', 'Action'].map(header => (
                        <th key={header} className="p-3 border-r last:border-r-0 whitespace-nowrap">{header}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {(record.rows || []).length === 0 ? (
                      <tr><td colSpan="10" className="p-4 text-center text-gray-500">No rows added yet.</td></tr>
                    ) : (
                      (record.rows || []).map(row => (
                        <DecisionMatrixRow
                          key={row.rowId}
                          row={row}
                          rules={record.rules}
                          onUpdate={handleUpdateRow}
                          onDelete={handleDeleteRowClick}
                          // Only set isEditing true if this specific rowId matches the currently editing row
                          isEditing={editingRowId === row.rowId} 
                          // The function to change which row is being edited
                          setIsEditing={(isEditing) => setEditingRowId(isEditing ? row.rowId : null)}
                        />
                      ))
                    )}
                  </tbody>
                </table>
              </div>

              {/* Footer Button */}
              <div className="mt-6 flex justify-end">
                <button className={PRIMARY_BUTTON} onClick={handleSendToSchedule}>
                  Send to Schedule
                </button>
              </div>

              {/* Modals */}
              <RuleConfigModal
                isOpen={isRulesModalOpen}
                onClose={() => setIsRulesModalOpen(false)}
                rules={record.rules}
                onSave={handleSaveRules}
              />

              <ConfirmModal
                isOpen={isConfirmDeleteRowOpen}
                title="Confirm Row Deletion"
                message="Are you sure you want to delete this row? This action cannot be undone."
                onConfirm={handleConfirmDeleteRow}
                onCancel={() => setIsConfirmDeleteRowOpen(false)}
              />
            </div>
          );
        };

        // --- Components: Audit Schedule Page (Placeholder) ---

        const AuditSchedulePage = ({ scheduledRecords }) => {
          return (
            <div className="p-6">
              <div className="mb-6 border-b pb-4">
                <h1 className="text-3xl font-bold">Audit Schedule</h1>
                <p className="text-gray-600">Records sent from the Audit Decision Matrix.</p>
              </div>

              <div className="space-y-4">
                {scheduledRecords.length === 0 ? (
                  <p className="text-gray-500">No records have been sent to the Audit Schedule.</p>
                ) : (
                  scheduledRecords.map(record => (
                    <div key={record.id} className="p-4 border border-blue-200 rounded-lg shadow-sm bg-blue-50">
                      <h3 className="text-xl font-bold text-blue-800">{record.name}</h3>
                      <p className="text-sm text-gray-600">Coordinator: {record.coordinator}</p>
                      <p className="text-sm text-gray-600">Rows: {record.rows.length} | Last Updated: {new Date(record.updatedAt).toLocaleDateString()}</p>
                    </div>
                  ))
                )}
              </div>
            </div>
          );
        };

        // --- Main Application Component ---

        const App = () => {
          const { route, params, navigate } = useRoute();
          const [records, setRecords] = useState(() => getLocalStorageItem(DECISION_RECORDS_KEY, []));
          const [scheduledRecords, setScheduledRecords] = useState(() => getLocalStorageItem(SCHEDULE_RECORDS_KEY, []));

          // Sync state to localStorage on change
          useEffect(() => {
            setLocalStorageItem(DECISION_RECORDS_KEY, records);
          }, [records]);

          useEffect(() => {
            setLocalStorageItem(SCHEDULE_RECORDS_KEY, scheduledRecords);
          }, [scheduledRecords]);

          // Main Content Router
          const renderMainContent = () => {
            switch (route) {
              case 'audit-decision-matrix':
                return <AuditDecisionMatrixListing navigate={navigate} records={records} setRecords={setRecords} />;
              case 'decision-matrix':
                return <DecisionMatrixRecordPage id={params.id} records={records} setRecords={setRecords} navigate={navigate} setScheduledRecords={setScheduledRecords} />;
              case 'audit-schedule':
                return <AuditSchedulePage scheduledRecords={scheduledRecords} />;
              default:
                // Default to the main listing page
                return <AuditDecisionMatrixListing navigate={navigate} records={records} setRecords={setRecords} />;
            }
          };

          return (
            <div className="flex min-h-screen font-sans">
              {/* Sidebar */}
              <Sidebar navigate={navigate} activeRoute={route} />

              {/* Main Content Area */}
              <div className="ml-[220px] flex-grow bg-gray-50">
                {renderMainContent()}
              </div>
            </div>
          );
        };

        // --- Render the App ---
        const rootElement = document.getElementById('root');
        ReactDOM.createRoot(rootElement).render(<React.StrictMode><App /></React.StrictMode>);
    </script>
</body>
</html>
